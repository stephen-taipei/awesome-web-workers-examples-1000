# 多池協調 (Multi-pool Coordination)

本範例展示如何協調多個不同用途的 Worker 池，以流水線 (Pipeline) 方式處理複雜的多階段任務。

## 功能特點

1.  **流水線架構 (Pipelining)**：
    -   模擬了一個經典的資料處理流程：`IO (讀取) -> CPU (運算) -> Render (輸出)`。
    -   每個階段由獨立的 Worker 池負責，實現關注點分離。
2.  **異質資源池**：
    -   **I/O Pool (4 Workers)**：模擬高並發但輕量的 I/O 操作。
    -   **CPU Pool (2 Workers)**：模擬耗時的計算操作，數量較少。
    -   **Render Pool (2 Workers)**：模擬最終結果生成。
3.  **非同步流轉**：
    -   任務在各階段之間自動流轉，無需主執行緒頻繁干預細節。
    -   每個池維護獨立的任務佇列，當前階段完成後自動將任務推送到下一階段的佇列。

## 技術重點

-   **狀態管理**：主執行緒作為協調者 (Coordinator)，維護所有作業 (Job) 在流水線中的位置與狀態。
-   **解耦設計**：各個階段的 Worker 互不影響，可以獨立擴展（例如 I/O 慢就增加 I/O Worker，CPU 慢就增加 CPU Worker）。
-   **佇列緩衝**：各階段之間的佇列起到了緩衝作用，能夠吸收上游突發的流量，保護下游不被壓垮。

## 使用方式

1.  點擊「提交新作業」，手動將一個新作業推入 I/O 階段。
2.  觀察作業如何依序通過三個階段：
    -   首先進入 I/O Pool 佇列，被 I/O Worker 處理。
    -   完成後進入 CPU Pool 佇列，等待運算。
    -   最後進入 Render Pool，完成後顯示在下方列表。
3.  開啟「自動模式」，模擬連續的作業流，觀察系統如何在負載下運作，以及哪個階段會成為瓶頸（通常是 CPU 階段，因為處理時間長且 Worker 少）。

## 應用場景

-   **影像/影片處理**：解碼 (IO) -> 濾鏡處理 (CPU) -> 編碼 (CPU/IO)。
-   **ETL 流程**：資料萃取 (Extract) -> 資料轉換 (Transform) -> 資料載入 (Load)。
-   **即時數據分析**：數據接收 -> 聚合運算 -> 視覺化更新。
